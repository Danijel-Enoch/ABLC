{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletSDKConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, linkAPIUrl, diagnostic) {\n    let WebSocketClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : WebSocket;\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.diagnostic = diagnostic;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws;\n    // attempt to reconnect every 5 seconds when disconnected\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(state => {\n      var _a;\n      return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n        state,\n        sessionIdHash: Session_1.Session.hash(sessionId)\n      });\n    }),\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1),\n    // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),\n    // wait 5 seconds\n    (0, operators_1.delay)(5000),\n    // check whether it's destroyed again\n    (0, operators_1.filter)(_ => !this.destroyed),\n    // reconnect\n    (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)()).subscribe());\n    // perform authentication upon connection\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)),\n    // if not CONNECTED, emit false immediately\n    (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false))).subscribe(connected => this.connectedSubject.next(connected)));\n    // send heartbeat every n seconds while connected\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, start the heartbeat timer\n    (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe(i =>\n    // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n    // handle server's heartbeat responses\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat()));\n    // handle link status updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      var _a;\n      const msg = m;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    }));\n    // handle session config updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      var _a;\n      const msg = m;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    var _a;\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n  destroy() {\n    var _a;\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.destroyed = true;\n  }\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n  get onceConnected$() {\n    return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n  get onceLinked$() {\n    return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), (0, operators_1.map)(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n  setSessionMetadata(key, value) {\n    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n  publishEvent(event, data) {\n    let callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n      return res.eventId;\n    }));\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n  makeRequest(message) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n    const reqId = message.id;\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return (0, rxjs_1.throwError)(err);\n    }\n    // await server message with corresponding id\n    return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n  }\n  authenticate() {\n    const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n  sendIsLinked() {\n    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n  sendGetSessionConfig() {\n    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n}\nexports.WalletSDKConnection = WalletSDKConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","WalletSDKConnection","rxjs_1","require","operators_1","Session_1","types_1","ClientMessage_1","DiagnosticLogger_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","constructor","sessionId","sessionKey","linkAPIUrl","diagnostic","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","tap","state","_a","log","EVENTS","CONNECTED_STATE_CHANGE","sessionIdHash","Session","hash","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","LINKED","linked","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","metadata","keys","undefined","webhookId","webhookUrl","Error","STARTED_CONNECTING","destroy","unsubscribe","disconnect","isDestroyed","connected$","asObservable","onceConnected$","v","take","linked$","onceLinked$","sessionConfig$","incomingEvent$","sme","eventId","event","data","setSessionMetadata","key","message","ClientMessageSetSessionConfig","id","makeRequest","res","isServerMessageFail","error","publishEvent","callWebhook","ClientMessagePublishEvent","sendData","JSON","stringify","Date","now","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"sources":["/Users/air/Downloads/ABLC/node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletSDKConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletSDKConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.diagnostic = diagnostic;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, types_1.IntNumber)(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe((0, operators_1.tap)(state => {\n            var _a;\n            return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n                state,\n                sessionIdHash: Session_1.Session.hash(sessionId),\n            });\n        }), \n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), \n        // if DISCONNECTED and not destroyed\n        (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        (0, operators_1.delay)(5000), \n        // check whether it's destroyed again\n        (0, operators_1.filter)(_ => !this.destroyed), \n        // reconnect\n        (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), \n        // if not CONNECTED, emit false immediately\n        (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe((0, operators_1.filter)(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                linked: msg.linked,\n                type: m.type,\n                onlineGuests: msg.onlineGuests,\n            });\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined,\n            });\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata,\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        var _a;\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    destroy() {\n        var _a;\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.destroyed = true;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), (0, operators_1.map)(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value },\n        });\n        return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook,\n        });\n        return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return (0, rxjs_1.throwError)(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n    }\n    authenticate() {\n        const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey,\n        });\n        return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletSDKConnection = WalletSDKConnection;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,mBAAmB,GAAG,KAAK,CAAC;AACpC,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAME,SAAS,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAC7C,MAAMG,OAAO,GAAGH,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMI,eAAe,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMK,kBAAkB,GAAGL,OAAO,CAAC,oBAAoB,CAAC;AACxD,MAAMM,aAAa,GAAGN,OAAO,CAAC,eAAe,CAAC;AAC9C,MAAMO,eAAe,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMQ,kBAAkB,GAAG,KAAK;AAChC,MAAMC,eAAe,GAAG,KAAK;AAC7B;AACA;AACA;AACA,MAAMX,mBAAmB,CAAC;EACtB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIY,WAAW,CAACC,SAAS,EAAEC,UAAU,EAAEC,UAAU,EAAEC,UAAU,EAA8B;IAAA,IAA5BC,cAAc,uEAAGC,SAAS;IACjF,IAAI,CAACL,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACE,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACG,aAAa,GAAG,IAAIlB,MAAM,CAACmB,YAAY,EAAE;IAC9C,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC,EAAElB,OAAO,CAACmB,SAAS,EAAE,CAAC,CAAC;IAC1C,IAAI,CAACC,gBAAgB,GAAG,IAAIxB,MAAM,CAACyB,eAAe,CAAC,KAAK,CAAC;IACzD,IAAI,CAACC,aAAa,GAAG,IAAI1B,MAAM,CAACyB,eAAe,CAAC,KAAK,CAAC;IACtD,IAAI,CAACE,oBAAoB,GAAG,IAAI3B,MAAM,CAAC4B,aAAa,CAAC,CAAC,CAAC;IACvD,MAAMC,EAAE,GAAG,IAAItB,aAAa,CAACuB,WAAW,CAAChB,UAAU,GAAG,MAAM,EAAEE,cAAc,CAAC;IAC7E,IAAI,CAACa,EAAE,GAAGA,EAAE;IACZ;IACA,IAAI,CAACX,aAAa,CAACa,GAAG,CAACF,EAAE,CAACG,gBAAgB,CACrCC,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAACgC,GAAG,EAAEC,KAAK,IAAI;MACpC,IAAIC,EAAE;MACN,OAAO,CAACA,EAAE,GAAG,IAAI,CAACrB,UAAU,MAAM,IAAI,IAAIqB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,GAAG,CAAC/B,kBAAkB,CAACgC,MAAM,CAACC,sBAAsB,EAAE;QACxHJ,KAAK;QACLK,aAAa,EAAErC,SAAS,CAACsC,OAAO,CAACC,IAAI,CAAC9B,SAAS;MACnD,CAAC,CAAC;IACN,CAAC,CAAC;IACF;IACA,CAAC,CAAC,EAAEV,WAAW,CAACyC,IAAI,EAAE,CAAC,CAAC;IACxB;IACA,CAAC,CAAC,EAAEzC,WAAW,CAAC0C,MAAM,EAAEC,EAAE,IAAIA,EAAE,KAAKtC,aAAa,CAACuC,eAAe,CAACC,YAAY,IAAI,CAAC,IAAI,CAAC3B,SAAS,CAAC;IACnG;IACA,CAAC,CAAC,EAAElB,WAAW,CAAC8C,KAAK,EAAE,IAAI,CAAC;IAC5B;IACA,CAAC,CAAC,EAAE9C,WAAW,CAAC0C,MAAM,EAAEK,CAAC,IAAI,CAAC,IAAI,CAAC7B,SAAS,CAAC;IAC7C;IACA,CAAC,CAAC,EAAElB,WAAW,CAACgD,OAAO,EAAED,CAAC,IAAIpB,EAAE,CAACsB,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEjD,WAAW,CAACkD,KAAK,GAAG,CAAC,CACjEC,SAAS,EAAE,CAAC;IACjB;IACA,IAAI,CAACnC,aAAa,CAACa,GAAG,CAACF,EAAE,CAACG,gBAAgB,CACrCC,IAAI;IACT;IACA,CAAC,CAAC,EAAE/B,WAAW,CAACyC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEzC,WAAW,CAACoD,SAAS,EAAET,EAAE,IAAI,CAAC,CAAC,EAAE7C,MAAM,CAACuD,GAAG,EAAE,MAAMV,EAAE,KAAKtC,aAAa,CAACuC,eAAe,CAACU,SAAS;IAC/H;IACA,IAAI,CAACC,YAAY,EAAE,CAACxB,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAACgC,GAAG,EAAEe,CAAC,IAAI,IAAI,CAACS,YAAY,EAAE,CAAC,EAAE,CAAC,CAAC,EAAExD,WAAW,CAACgC,GAAG,EAAEe,CAAC,IAAI,IAAI,CAACU,oBAAoB,EAAE,CAAC,EAAE,CAAC,CAAC,EAAEzD,WAAW,CAAC0D,GAAG,EAAEX,CAAC,IAAI,IAAI,CAAC,CAAC;IACjK;IACA,CAAC,CAAC,EAAEjD,MAAM,CAAC6D,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE3D,WAAW,CAAC4D,oBAAoB,GAAG,EAAE,CAAC,CAAC,EAAE5D,WAAW,CAAC6D,UAAU,EAAEd,CAAC,IAAI,CAAC,CAAC,EAAEjD,MAAM,CAAC6D,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,CACrHR,SAAS,CAACW,SAAS,IAAI,IAAI,CAACxC,gBAAgB,CAACyC,IAAI,CAACD,SAAS,CAAC,CAAC,CAAC;IACnE;IACA,IAAI,CAAC9C,aAAa,CAACa,GAAG,CAACF,EAAE,CAACG,gBAAgB,CACrCC,IAAI;IACT;IACA,CAAC,CAAC,EAAE/B,WAAW,CAACyC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEzC,WAAW,CAACoD,SAAS,EAAET,EAAE,IAAI,CAAC,CAAC,EAAE7C,MAAM,CAACuD,GAAG,EAAE,MAAMV,EAAE,KAAKtC,aAAa,CAACuC,eAAe,CAACU,SAAS;IAC/H;IACA,CAAC,CAAC,EAAExD,MAAM,CAACkE,KAAK,EAAE,CAAC,EAAEzD,kBAAkB,CAAC,CAAC,CAAC,CAAC,CACtC4C,SAAS,CAACc,CAAC;IAChB;IACA;IACAA,CAAC,KAAK,CAAC,GAAG,IAAI,CAACC,mBAAmB,EAAE,GAAG,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;IACzD;IACA,IAAI,CAACnD,aAAa,CAACa,GAAG,CAACF,EAAE,CAACyC,aAAa,CAClCrC,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0C,MAAM,EAAE2B,CAAC,IAAIA,CAAC,KAAK,GAAG,CAAC,CAAC,CAC7ClB,SAAS,CAACJ,CAAC,IAAI,IAAI,CAACmB,mBAAmB,EAAE,CAAC,CAAC;IAChD;IACA,IAAI,CAAClD,aAAa,CAACa,GAAG,CAACF,EAAE,CAAC2C,iBAAiB,CACtCvC,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0C,MAAM,EAAE2B,CAAC,IAAI,CAAC,YAAY,EAAE,QAAQ,CAAC,CAACE,QAAQ,CAACF,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CAC7ErB,SAAS,CAACkB,CAAC,IAAI;MAChB,IAAInC,EAAE;MACN,MAAMuC,GAAG,GAAGJ,CAAC;MACb,CAACnC,EAAE,GAAG,IAAI,CAACrB,UAAU,MAAM,IAAI,IAAIqB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,GAAG,CAAC/B,kBAAkB,CAACgC,MAAM,CAACsC,MAAM,EAAE;QACjGpC,aAAa,EAAErC,SAAS,CAACsC,OAAO,CAACC,IAAI,CAAC9B,SAAS,CAAC;QAChDiE,MAAM,EAAEF,GAAG,CAACE,MAAM;QAClBH,IAAI,EAAEH,CAAC,CAACG,IAAI;QACZI,YAAY,EAAEH,GAAG,CAACG;MACtB,CAAC,CAAC;MACF,IAAI,CAACpD,aAAa,CAACuC,IAAI,CAACU,GAAG,CAACE,MAAM,IAAIF,GAAG,CAACG,YAAY,GAAG,CAAC,CAAC;IAC/D,CAAC,CAAC,CAAC;IACH;IACA,IAAI,CAAC5D,aAAa,CAACa,GAAG,CAACF,EAAE,CAAC2C,iBAAiB,CACtCvC,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0C,MAAM,EAAE2B,CAAC,IAAI,CAAC,oBAAoB,EAAE,sBAAsB,CAAC,CAACE,QAAQ,CAACF,CAAC,CAACG,IAAI,CAAC,CAAC,CAAC,CACnGrB,SAAS,CAACkB,CAAC,IAAI;MAChB,IAAInC,EAAE;MACN,MAAMuC,GAAG,GAAGJ,CAAC;MACb,CAACnC,EAAE,GAAG,IAAI,CAACrB,UAAU,MAAM,IAAI,IAAIqB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,GAAG,CAAC/B,kBAAkB,CAACgC,MAAM,CAACyC,uBAAuB,EAAE;QAClHvC,aAAa,EAAErC,SAAS,CAACsC,OAAO,CAACC,IAAI,CAAC9B,SAAS,CAAC;QAChDoE,aAAa,EAAEL,GAAG,IAAIA,GAAG,CAACM,QAAQ,GAAGtF,MAAM,CAACuF,IAAI,CAACP,GAAG,CAACM,QAAQ,CAAC,GAAGE;MACrE,CAAC,CAAC;MACF,IAAI,CAACxD,oBAAoB,CAACsC,IAAI,CAAC;QAC3BmB,SAAS,EAAET,GAAG,CAACS,SAAS;QACxBC,UAAU,EAAEV,GAAG,CAACU,UAAU;QAC1BJ,QAAQ,EAAEN,GAAG,CAACM;MAClB,CAAC,CAAC;IACN,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;EACI9B,OAAO,GAAG;IACN,IAAIf,EAAE;IACN,IAAI,IAAI,CAAChB,SAAS,EAAE;MAChB,MAAM,IAAIkE,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACA,CAAClD,EAAE,GAAG,IAAI,CAACrB,UAAU,MAAM,IAAI,IAAIqB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,GAAG,CAAC/B,kBAAkB,CAACgC,MAAM,CAACiD,kBAAkB,EAAE;MAC7G/C,aAAa,EAAErC,SAAS,CAACsC,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC9B,SAAS;IACxD,CAAC,CAAC;IACF,IAAI,CAACiB,EAAE,CAACsB,OAAO,EAAE,CAACE,SAAS,EAAE;EACjC;EACA;AACJ;AACA;AACA;EACImC,OAAO,GAAG;IACN,IAAIpD,EAAE;IACN,IAAI,CAAClB,aAAa,CAACuE,WAAW,EAAE;IAChC,IAAI,CAAC5D,EAAE,CAAC6D,UAAU,EAAE;IACpB,CAACtD,EAAE,GAAG,IAAI,CAACrB,UAAU,MAAM,IAAI,IAAIqB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,GAAG,CAAC/B,kBAAkB,CAACgC,MAAM,CAACS,YAAY,EAAE;MACvGP,aAAa,EAAErC,SAAS,CAACsC,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC9B,SAAS;IACxD,CAAC,CAAC;IACF,IAAI,CAACQ,SAAS,GAAG,IAAI;EACzB;EACA,IAAIuE,WAAW,GAAG;IACd,OAAO,IAAI,CAACvE,SAAS;EACzB;EACA;AACJ;AACA;AACA;EACI,IAAIwE,UAAU,GAAG;IACb,OAAO,IAAI,CAACpE,gBAAgB,CAACqE,YAAY,EAAE;EAC/C;EACA;AACJ;AACA;AACA;EACI,IAAIC,cAAc,GAAG;IACjB,OAAO,IAAI,CAACF,UAAU,CAAC3D,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0C,MAAM,EAAEmD,CAAC,IAAIA,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE7F,WAAW,CAAC8F,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE9F,WAAW,CAAC0D,GAAG,EAAE,MAAM,KAAK,CAAC,CAAC,CAAC;EAC9H;EACA;AACJ;AACA;AACA;EACI,IAAIqC,OAAO,GAAG;IACV,OAAO,IAAI,CAACvE,aAAa,CAACmE,YAAY,EAAE;EAC5C;EACA;AACJ;AACA;AACA;EACI,IAAIK,WAAW,GAAG;IACd,OAAO,IAAI,CAACD,OAAO,CAAChE,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0C,MAAM,EAAEmD,CAAC,IAAIA,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE7F,WAAW,CAAC8F,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE9F,WAAW,CAAC0D,GAAG,EAAE,MAAM,KAAK,CAAC,CAAC,CAAC;EAC3H;EACA;AACJ;AACA;AACA;EACI,IAAIuC,cAAc,GAAG;IACjB,OAAO,IAAI,CAACxE,oBAAoB,CAACkE,YAAY,EAAE;EACnD;EACA;AACJ;AACA;AACA;EACI,IAAIO,cAAc,GAAG;IACjB,OAAO,IAAI,CAACvE,EAAE,CAAC2C,iBAAiB,CAACvC,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0C,MAAM,EAAE2B,CAAC,IAAI;MAC/D,IAAIA,CAAC,CAACG,IAAI,KAAK,OAAO,EAAE;QACpB,OAAO,KAAK;MAChB;MACA,MAAM2B,GAAG,GAAG9B,CAAC;MACb,OAAQ,OAAO8B,GAAG,CAACzF,SAAS,KAAK,QAAQ,IACrC,OAAOyF,GAAG,CAACC,OAAO,KAAK,QAAQ,IAC/B,OAAOD,GAAG,CAACE,KAAK,KAAK,QAAQ,IAC7B,OAAOF,GAAG,CAACG,IAAI,KAAK,QAAQ;IACpC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEtG,WAAW,CAAC0D,GAAG,EAAEW,CAAC,IAAIA,CAAC,CAAC,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIkC,kBAAkB,CAACC,GAAG,EAAE5G,KAAK,EAAE;IAC3B,MAAM6G,OAAO,GAAG,CAAC,CAAC,EAAEtG,eAAe,CAACuG,6BAA6B,EAAE;MAC/DC,EAAE,EAAE,CAAC,CAAC,EAAEzG,OAAO,CAACmB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC5CV,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBqE,QAAQ,EAAE;QAAE,CAACyB,GAAG,GAAG5G;MAAM;IAC7B,CAAC,CAAC;IACF,OAAO,IAAI,CAACgG,cAAc,CAAC7D,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAACgD,OAAO,EAAED,CAAC,IAAI,IAAI,CAAC6D,WAAW,CAACH,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEzG,WAAW,CAAC0D,GAAG,EAAEmD,GAAG,IAAI;MAClH,IAAI,CAAC,CAAC,EAAEvG,eAAe,CAACwG,mBAAmB,EAAED,GAAG,CAAC,EAAE;QAC/C,MAAM,IAAIzB,KAAK,CAACyB,GAAG,CAACE,KAAK,IAAI,gCAAgC,CAAC;MAClE;IACJ,CAAC,CAAC,CAAC;EACP;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACX,KAAK,EAAEC,IAAI,EAAuB;IAAA,IAArBW,WAAW,uEAAG,KAAK;IACzC,MAAMR,OAAO,GAAG,CAAC,CAAC,EAAEtG,eAAe,CAAC+G,yBAAyB,EAAE;MAC3DP,EAAE,EAAE,CAAC,CAAC,EAAEzG,OAAO,CAACmB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC5CV,SAAS,EAAE,IAAI,CAACA,SAAS;MACzB2F,KAAK;MACLC,IAAI;MACJW;IACJ,CAAC,CAAC;IACF,OAAO,IAAI,CAACjB,WAAW,CAACjE,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAACgD,OAAO,EAAED,CAAC,IAAI,IAAI,CAAC6D,WAAW,CAACH,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEzG,WAAW,CAAC0D,GAAG,EAAEmD,GAAG,IAAI;MAC/G,IAAI,CAAC,CAAC,EAAEvG,eAAe,CAACwG,mBAAmB,EAAED,GAAG,CAAC,EAAE;QAC/C,MAAM,IAAIzB,KAAK,CAACyB,GAAG,CAACE,KAAK,IAAI,yBAAyB,CAAC;MAC3D;MACA,OAAOF,GAAG,CAACT,OAAO;IACtB,CAAC,CAAC,CAAC;EACP;EACAe,QAAQ,CAACV,OAAO,EAAE;IACd,IAAI,CAAC9E,EAAE,CAACwF,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACZ,OAAO,CAAC,CAAC;EAC7C;EACAvC,mBAAmB,GAAG;IAClB,IAAI,CAAC/C,qBAAqB,GAAGmG,IAAI,CAACC,GAAG,EAAE;EAC3C;EACApD,SAAS,GAAG;IACR,IAAImD,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAACpG,qBAAqB,GAAGZ,kBAAkB,GAAG,CAAC,EAAE;MAClE,IAAI,CAACoB,EAAE,CAAC6D,UAAU,EAAE;MACpB;IACJ;IACA,IAAI;MACA,IAAI,CAAC7D,EAAE,CAACwF,QAAQ,CAAC,GAAG,CAAC;IACzB,CAAC,CACD,OAAOjF,EAAE,EAAE,CAAE;EACjB;EACA0E,WAAW,CAACH,OAAO,EAA6B;IAAA,IAA3Be,OAAO,uEAAGhH,eAAe;IAC1C,MAAMiH,KAAK,GAAGhB,OAAO,CAACE,EAAE;IACxB,IAAI;MACA,IAAI,CAACQ,QAAQ,CAACV,OAAO,CAAC;IAC1B,CAAC,CACD,OAAOiB,GAAG,EAAE;MACR,OAAO,CAAC,CAAC,EAAE5H,MAAM,CAAC6H,UAAU,EAAED,GAAG,CAAC;IACtC;IACA;IACA,OAAO,IAAI,CAAC/F,EAAE,CAAC2C,iBAAiB,CAACvC,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC4H,WAAW,EAAEJ,OAAO,EAAE,CAAC,CAAC,EAAE1H,MAAM,CAAC6H,UAAU,EAAE,IAAIvC,KAAK,CAAE,WAAUqC,KAAM,YAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEzH,WAAW,CAAC0C,MAAM,EAAE2B,CAAC,IAAIA,CAAC,CAACsC,EAAE,KAAKc,KAAK,CAAC,EAAE,CAAC,CAAC,EAAEzH,WAAW,CAAC8F,IAAI,EAAE,CAAC,CAAC,CAAC;EACzN;EACAvC,YAAY,GAAG;IACX,MAAMkB,GAAG,GAAG,CAAC,CAAC,EAAEtE,eAAe,CAAC0H,wBAAwB,EAAE;MACtDlB,EAAE,EAAE,CAAC,CAAC,EAAEzG,OAAO,CAACmB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC5CV,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,UAAU,EAAE,IAAI,CAACA;IACrB,CAAC,CAAC;IACF,OAAO,IAAI,CAACiG,WAAW,CAACnC,GAAG,CAAC,CAAC1C,IAAI,CAAC,CAAC,CAAC,EAAE/B,WAAW,CAAC0D,GAAG,EAAEmD,GAAG,IAAI;MAC1D,IAAI,CAAC,CAAC,EAAEvG,eAAe,CAACwG,mBAAmB,EAAED,GAAG,CAAC,EAAE;QAC/C,MAAM,IAAIzB,KAAK,CAACyB,GAAG,CAACE,KAAK,IAAI,uBAAuB,CAAC;MACzD;IACJ,CAAC,CAAC,CAAC;EACP;EACAvD,YAAY,GAAG;IACX,MAAMiB,GAAG,GAAG,CAAC,CAAC,EAAEtE,eAAe,CAAC2H,qBAAqB,EAAE;MACnDnB,EAAE,EAAE,CAAC,CAAC,EAAEzG,OAAO,CAACmB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC5CV,SAAS,EAAE,IAAI,CAACA;IACpB,CAAC,CAAC;IACF,IAAI,CAACyG,QAAQ,CAAC1C,GAAG,CAAC;EACtB;EACAhB,oBAAoB,GAAG;IACnB,MAAMgB,GAAG,GAAG,CAAC,CAAC,EAAEtE,eAAe,CAAC4H,6BAA6B,EAAE;MAC3DpB,EAAE,EAAE,CAAC,CAAC,EAAEzG,OAAO,CAACmB,SAAS,EAAE,IAAI,CAACD,SAAS,EAAE,CAAC;MAC5CV,SAAS,EAAE,IAAI,CAACA;IACpB,CAAC,CAAC;IACF,IAAI,CAACyG,QAAQ,CAAC1C,GAAG,CAAC;EACtB;AACJ;AACA9E,OAAO,CAACE,mBAAmB,GAAGA,mBAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}