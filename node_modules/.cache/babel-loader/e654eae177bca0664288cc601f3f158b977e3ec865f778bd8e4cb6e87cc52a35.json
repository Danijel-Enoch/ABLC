{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nexport function takeLast(count) {\n  return function takeLastOperatorFunction(source) {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\nvar TakeLastOperator = /*@__PURE__*/function () {\n  function TakeLastOperator(total) {\n    this.total = total;\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n  TakeLastOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  };\n  return TakeLastOperator;\n}();\nvar TakeLastSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(TakeLastSubscriber, _super);\n  function TakeLastSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n    _this.total = total;\n    _this.ring = new Array();\n    _this.count = 0;\n    return _this;\n  }\n  TakeLastSubscriber.prototype._next = function (value) {\n    var ring = this.ring;\n    var total = this.total;\n    var count = this.count++;\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      var index = count % total;\n      ring[index] = value;\n    }\n  };\n  TakeLastSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n    var count = this.count;\n    if (count > 0) {\n      var total = this.count >= this.total ? this.total : this.count;\n      var ring = this.ring;\n      for (var i = 0; i < total; i++) {\n        var idx = count++ % total;\n        destination.next(ring[idx]);\n      }\n    }\n    destination.complete();\n  };\n  return TakeLastSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAU,MAAE,OAAM;AAC3B,SAASC,iCAA+B;AACxC,SAASC,uBAAa,yCAAsB;AA8C5C,SAAMC,aAAU,qBAAyB;OACvC,SAAOC,QAAS;SACd,SAASC,wBAAQ;QACfC,UAAO,GAAK;MACb;WACC;MACD;IACD;EACH;AAED;IACEC,gCAAiC;WAAbA,gBAAa;IAC/B,IAAI,MAAK,QAAS;QAChB,UAAU;MACX;IACF;EAED;kBACS,CAAMC,SAAC,CAASC,IAAC,GAAI,oBAAmB,QAAU,EAAE;IAC5D;EACH;EAVA,OAUCF;AAOD;IAAoCG,4CAAaC;EAI/CX,oCAAY,QAAoC;WAAhDU,kBACE,YAAM,OAAY;IAD4B,YAAKC,MAAL,CAAKF,IAAQ;IAHrDG,WAAI,GAAaC,KAAI;IACrBD,aAAK,IAAaE;;IAIzB;EAES;oBACK,CAAIN,SAAM;IACvB,IAAMO,OAAK,IAAG,CAAIA,IAAC;IACnB,IAAMF,KAAK,GAAG,IAAI,CAACA,KAAK;IAExB,IAAIP,KAAK,OAAM,MAAG,EAAK;QACrBS,IAAI,CAACC,MAAK,QAAO;MAClBD;WACC;MACA,IAAIE,KAAC,GAAMX,KAAG,GAAMO;MACrBE;IACF;EAES;oBACF,CAAWP,SAAQ,UAAW,GAAC;IACrC,IAAIU,WAAQ,GAAK,IAAK,CAACA;IAEvB,IAAIZ,KAAK,GAAG,IAAG;QACbA,KAAM,IAAK;MACX,IAAMO,KAAI,GAAI,IAAK,MAAK;MAExB,QAAK,GAAK,IAAI,CAAEE,IAAI;WAClB,IAAMI,IAAG,CAAG,EAACA,IAAKN,KAAG,EAAGM,KAAM;QAC9B,UAAWb,KAAK,EAAC,GAAKO,KAAK;QAC5BK;MACF;IAED;IACDA;EACH;EArCoC,yBAqCnC","names":["tslib_1","Subscriber","ArgumentOutOfRangeError","empty","takeLast","takeLastOperatorFunction","count","TakeLastOperator","prototype","call","TakeLastSubscriber","_super","_this","total","Array","ring","length","index","destination","i"],"sources":["/Users/air/Downloads/ABLC/node_modules/rxjs/src/internal/operators/takeLast.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * ![](takeLast.png)\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * ## Example\n * Take the last 3 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { takeLast } from 'rxjs/operators';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return function takeLastOperatorFunction(source: Observable<T>): Observable<T> {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\n\nclass TakeLastOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeLastSubscriber<T> extends Subscriber<T> {\n  private ring: Array<T> = new Array();\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const ring = this.ring;\n    const total = this.total;\n    const count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      const index = count % total;\n      ring[index] = value;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    let count = this.count;\n\n    if (count > 0) {\n      const total = this.count >= this.total ? this.total : this.count;\n      const ring  = this.ring;\n\n      for (let i = 0; i < total; i++) {\n        const idx = (count++) % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}