{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nvar ConnectableObservable = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableObservable, _super);\n  function ConnectableObservable(source, subjectFactory) {\n    var _this = _super.call(this) || this;\n    _this.source = source;\n    _this.subjectFactory = subjectFactory;\n    _this._refCount = 0;\n    _this._isComplete = false;\n    return _this;\n  }\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  };\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  };\n  ConnectableObservable.prototype.refCount = function () {\n    return higherOrderRefCount()(this);\n  };\n  return ConnectableObservable;\n}(Observable);\nexport { ConnectableObservable };\nexport var connectableObservableDescriptor = /*@__PURE__*/function () {\n  var connectableProto = ConnectableObservable.prototype;\n  return {\n    operator: {\n      value: null\n    },\n    _refCount: {\n      value: 0,\n      writable: true\n    },\n    _subject: {\n      value: null,\n      writable: true\n    },\n    _connection: {\n      value: null,\n      writable: true\n    },\n    _subscribe: {\n      value: connectableProto._subscribe\n    },\n    _isComplete: {\n      value: connectableProto._isComplete,\n      writable: true\n    },\n    getSubject: {\n      value: connectableProto.getSubject\n    },\n    connect: {\n      value: connectableProto.connect\n    },\n    refCount: {\n      value: connectableProto.refCount\n    }\n  };\n}();\nvar ConnectableSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableSubscriber, _super);\n  function ConnectableSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n    _this.connectable = connectable;\n    return _this;\n  }\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n    _super.prototype._error.call(this, err);\n  };\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    _super.prototype._complete.call(this);\n  };\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n  return ConnectableSubscriber;\n}(SubjectSubscriber);\nvar RefCountOperator = /*@__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n    return subscription;\n  };\n  return RefCountOperator;\n}();\nvar RefCountSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(RefCountSubscriber, _super);\n  function RefCountSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n    _this.connectable = connectable;\n    return _this;\n  }\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n    this.connectable = null;\n    var refCount = connectable._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n    connectable._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n  return RefCountSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AAAA,OAAO,KAAWA,oBAAmB;AAErC,SAASC,iBAAY,QAAM,YAAgB;AAC3C,SAASC,UAAU,QAAQ,eAAe;AAC1C,SAASC,kBAAc,eAAM;AAE7B,SAASC,YAAY,yBAAqB;AAK1C;IAA8CC,+CAAaC;EAQzDN,uCACsB;WADtBK,qBAEE,OAAO,gBACR;IAHkB,YAAMC,MAAN,KAAqB;IAClBC,qBAAc;IAN1BA,oBAAsB;IAGhCA,kBAAW;;IAKV;EAGD;uBACc,UAAa,WAAU,aAAYC;IAChD;EAES;uBACQ,CAAIC,SAAS,CAACC;IAC9B,IAAIC,OAAC,GAAO,IAAI,SAAQ;QACtB,QAAK,WAAW,CAAIC,SAAC;MACtB;IACD;IACD;EAED;uBACmB,UAAK,QAAY;IAClC,IAAIC,UAAC,GAAY;QACf,WAAK;MACL,gBAAa,GAAK;MAClBA,UAAU,GAAC,IAAI,YAAW;gBACvB,IAAS,CAAC,IAAI,QACbC,SAAU,CAAC,yBAAQ;UACrBD,UAAK,OAAW,EAAG;QACnB,gBAAa;QACdA;MACF;IACD;IACD;EAED;uBACS,UAAmB,CAAEE,QAAwB;IACrD;EACH;EA5C8C,4BA4C7C;;AAED,SAAOV,qBAAM;OACX,IAAMW,+BAAwB,gBAAgC;EAC9D,oBAAO;SACL;IACAC,UAAS;MAAEC,KAAE,EAAK;IAAK;IACvBC,SAAQ,EAAE;MAAED,KAAK,EAAE;MAAYE,QAAE,EAAQ;IAAE,CAAI;IAC/CC;MAAWH,KAAI,MAAO;MAAAE,QAAc;IAAU;IAC9CE,WAAU,EAAE;MAAEJ,KAAK,EAAE;MAAAE,UAAiB;IAAA;IACtCG,YAAW;MAAEL,KAAE,EAAKM,gBAAE,CAAgBD;IAAC,CAAW;IAClDE,WAAU,EAAE;MAAEP,KAAK,EAAEM,gBAAiB,YAAY;MAAAJ;IAAA;IAClDV,UAAS,EAAE;MAAAQ,KAAO,kBAAiB;IAAS;IAC5CQ,SAAQ;MAAER,KAAE,EAAKM,gBAAE,CAAgBE;IAAC,CAAQ;IAC5CX;MAAAG;IAAA;EACA,CAAC;AAEL;IAAuCS,+CAAoBrB;EACzDN,uCAAY,QACQ;WADpB2B,qBAEE,YAAM,aACP;IAFmB,kBAAW,KAAX,kBAAqC;;IAExD;EACS;uBACS,UAAG;IACpB,iBAAM;IACPrB;EACS;uBACS,WAAWsB,SAAQ;IACpC,IAAI,CAACC,YAAYJ,WAAG;IACpB,iBAAM;IACPnB;EACS;uBACS,CAAQG,SAAK,aAAY;IAC1C,IAAIoB,WAAW,GAAE;QACfA,WAAK;MACL,IAAM,YAAU,GAAG;MACnB,cAAY,cAAc;MAC1BA,WAAW,CAACV,SAAQ,GAAG;MACvBU,WAAW,CAACR,WAAW,IAAG;MAC1BQ,WAAI,YAAY;UACdhB,UAAU,EAAC;QACZA;MACF;IACF;EACH;EA3BuC,4BA2BtC;AAED;IACEiB,gCAAoB,YAAqC;WAArCA,4BAAqC;IACxD;EACD;kBAEU,4BAAqBtB;IACtB,eAAa,OAAS,CAAEqB,WAAC;IAEhCA,WAAM,UAAiB;IACvB,IAAME,aAAY,IAAGC,kBAAiB,WAAY;IAElD,IAAIC,YAAY,SAAQ;QACf,WAAY;MACpBF;IAED;IACD;EACH;EAjBA,OAiBCD;AAED;IAAoCE,4CAAa1B;EAI/CN,oCAAY,QACQ;WADpBgC,kBAEE,YAAM,aAAY;IADA,kBAAW,KAAX,kBAAqC;;IAExD;EAES;oBAEA,uBAAqB;IAC7B,IAAIH,WAAC,GAAa;QAChB,YAAK;MACL,eAAO;MACR;IAED;IACA,IAAM,YAAkB;IACxB,IAAId,QAAQ,cAAO;QACjBA,QAAK,OAAU;MACf,eAAO;MACR;IAEM;IACPc,WAAI,CAAQV,SAAM;QAChBJ,QAAK;MACL,eAAO;MACR;IAyBO;IACR,IAAMF,iBAAgB,WAAU;IAChC,IAAIqB,gBAAc,GAAKL;IAEvB,IAAI,kBAAgB;QAClBK,gBAAgB,KAAC,WAAc;MAChCA;IACF;EACH;EA7DoC,yBA6DnC","names":["tslib_1","SubjectSubscriber","Observable","Subscriber","Subscription","ConnectableObservable","_super","_this","subscriber","prototype","getSubject","subject","isStopped","connection","subscribe","refCount","connectableObservableDescriptor","operator","value","_refCount","writable","_subject","_connection","_subscribe","connectableProto","_isComplete","connect","ConnectableSubscriber","_complete","connectable","RefCountOperator","refCounter","RefCountSubscriber","subscription","sharedConnection"],"sources":["/Users/air/Downloads/ABLC/node_modules/rxjs/src/internal/observable/ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\n  const connectableProto = <any>ConnectableObservable.prototype;\n  return {\n    operator: { value: null as null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null as null, writable: true },\n    _connection: { value: null as null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n  };\n})();\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}