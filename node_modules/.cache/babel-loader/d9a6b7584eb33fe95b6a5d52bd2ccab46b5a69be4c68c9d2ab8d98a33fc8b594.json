{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ReplaySubject, _super);\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n    var _this = _super.call(this) || this;\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n    return _this;\n  }\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    if (!this.isStopped) {\n      var _events = this._events;\n      _events.push(value);\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    _super.prototype.next.call(this, value);\n  };\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    _super.prototype.next.call(this, value);\n  };\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n    return subscription;\n  };\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n    return _events;\n  };\n  return ReplaySubject;\n}(Subject);\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n  return ReplayEvent;\n}();","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAS,MAAM;AAExB,SAASC,OAAO,QAAM;AAEtB,SAASC,aAAY,mBAAQ;AAC7B,SAASC,oBAAmB,gBAAQ;AACpC,SAASC,2BAAyB,uBAAM;AACxC,SAASC,uBAAqB,QAAM,gCAAwB;AAQ5D;IAAsCC,uCAAUC;EAM9CP,+BAAY,EAA6CO,MAC7C;WADAD,sCAAqBE,SAAO;IAC5B;MADZC,UAGE,2BAUD;IAXmB;IAPZ,cAAO,KAA8B;MAGrCC,qCAAqC;IAM3C;IACA,SAAK,SAAW,KAAG,UAAa,IAAI;IAEpCC,KAAI,UAAU,YAAY;SACxB,QAAK;SACL,oBAAiB;SAClB;SAAM;QACLD,UAAS,KAAGE,MAAK,kBAAe;MACjCD;;IACF,OAEO;MACFA,KAAK,CAACE,YAAW;;WAEnBF,KAAQ;;eAIN,UAAQ,uBAAQ;SACjB;MACF;MACDG,aAAMC,KAAI;MACX;QAEOD;MACF;;UAEF,UAAK,iBAAwBC,KAAG;;eAElC,UAAM,eAAK,aAAOA;IACnB;MAGD,uCAAWC,WAAyBD;MAE5B,6BAA2B;IACjC;IACAR,MAAM,UAAY,KAAK,UAAU;;eAE7B,UAA2B;IAE/B,IAAIU,mBAAa;QACfH,OAAM,GAAIG,0BAA0B;QACrCT;WAAM,GAAIM,OAAK,OAAS;QACvBI,YAAY;QACb;YAAM;WAEL,kBAAmB,mBAAmB;MACvCA;IAED,OACE;MACD;MAEGA,mBAAmBC,mBAAE;;iBAErB;gBACD;;2BACI;MACL,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,IAAI,CAACC,UAAU,CAACC,MAAM,EAAEH,CAAC,EAAE,EAAE;QAClDE,UAAU,CAACT,IAAI,CAAkBC,OAAO,CAACM,CAAC,CAAE,CAAC;;KAEhD,MAEG;MACF,UAAU,GAAC,GAAKA,CAAC,MAAK,eAAa;QACpCE;;;QAEA;MAEDA,UAAO,MAAa;IACrB,OAED;MACEA,UAAa,SAAS;IACvB;IAEO;;eAEA,UAAc,QAAK,eAAY;IACrC,OAAM,eAAkB,IAACpB,UAAY;;eAG/B,UAAc,yBAAe;IACnC,IAAIsB,WAAWR,OAAK;IAKpB,eAAO,GAAW,IAAG,YAAa;QAChCS,WAAW,OAAO,CAACA,WAAW;eAC5B,GAAM;mBACP;QACDC,WAAW,GAAG;WACfA;MAEG,UAAWZ,OAAG,YAAa;QAC7B;MACD;MAEGY,WAAW;;QAEdC;MAEDD,WAAe;IAChB;IAEH,kBAAC;MAAAZ;;IAED;EACE;SAAmBR,aAAI;SAAiB;SACvCA;IACHsB,2BAAC;EAHD,SAGCA","names":["tslib_1","Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","ReplaySubject","_super","scheduler","bufferSize","windowTime","_this","Number","next","_events","value","_getNow","_infiniteTimeWindow","subscription","SubjectSubscription","i","len","subscriber","closed","now","_windowTime","spliceCount","eventsCount","ReplayEvent"],"sources":["/Users/air/Downloads/ABLC/node_modules/rxjs/src/internal/ReplaySubject.ts"],"sourcesContent":["import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      const _events = this._events;\n      _events.push(value);\n      // Since this method is invoked in every next() call than the buffer\n      // can overgrow the max size only by one item\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}