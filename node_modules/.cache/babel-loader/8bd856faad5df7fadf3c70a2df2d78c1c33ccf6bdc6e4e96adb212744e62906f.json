{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { Subscription } from './Subscription';\nvar AsyncSubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AsyncSubject, _super);\n  function AsyncSubject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.value = null;\n    _this.hasNext = false;\n    _this.hasCompleted = false;\n    return _this;\n  }\n  AsyncSubject.prototype._subscribe = function (subscriber) {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription.EMPTY;\n    }\n    return _super.prototype._subscribe.call(this, subscriber);\n  };\n  AsyncSubject.prototype.next = function (value) {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  };\n  AsyncSubject.prototype.error = function (error) {\n    if (!this.hasCompleted) {\n      _super.prototype.error.call(this, error);\n    }\n  };\n  AsyncSubject.prototype.complete = function () {\n    this.hasCompleted = true;\n    if (this.hasNext) {\n      _super.prototype.next.call(this, this.value);\n    }\n    _super.prototype.complete.call(this);\n  };\n  return AsyncSubject;\n}(Subject);\nexport { AsyncSubject };","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAS,MAAM;AAExB,SAASC,eAAc,WAAM;AAQ7B;IAAqCC,sCAAUC;EAA/CH;WAAAE;IACU,YAAKC,MAAU,KAAC;IAChBC,cAAO,IAAY;IACnBA,qBAAwB;;IAmCjC;EAhCC;cACU,CAACC,SAAQ,CAAEC;QACjB,aAAW;MACXC,UAAO,WAAa,YAAM;MAC3B;WACC,SAAUC,YAAW,IAAK,IAAE;MAC5BD,UAAU,CAACE,SAAQ,CAAEC,KAAC;MACtBH,UAAO,SAAY,EAAC;MACrB;IACD;IACD;EAED;cACO,CAAIF,SAAC,KAAY,GAAE;QACtB,KAAK,aAAa,EAAC;MACnB,IAAI,CAACK,QAAOA,KAAG;MAChB;IACF;EAED;cACO,CAAIL,SAAC,MAAc;QACtB,kBAAM;MACPF;IACF;EAED;cACO,UAAY,SAAQ;IACzB,IAAI,aAAY,GAAE;QAChB;MACDA;IACD;IACDA;EACH;EAtCqC,OAAOD,YAsC3C","names":["tslib_1","Subject","AsyncSubject","_super","_this","prototype","_subscribe","subscriber","hasCompleted","next","value"],"sources":["/Users/air/Downloads/ABLC/node_modules/rxjs/src/internal/AsyncSubject.ts"],"sourcesContent":["import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private value: T = null;\n  private hasNext: boolean = false;\n  private hasCompleted: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): Subscription {\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.hasCompleted && this.hasNext) {\n      subscriber.next(this.value);\n      subscriber.complete();\n      return Subscription.EMPTY;\n    }\n    return super._subscribe(subscriber);\n  }\n\n  next(value: T): void {\n    if (!this.hasCompleted) {\n      this.value = value;\n      this.hasNext = true;\n    }\n  }\n\n  error(error: any): void {\n    if (!this.hasCompleted) {\n      super.error(error);\n    }\n  }\n\n  complete(): void {\n    this.hasCompleted = true;\n    if (this.hasNext) {\n      super.next(this.value);\n    }\n    super.complete();\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}