{"ast":null,"code":"/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nexport function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n  var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  var subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n  return function (source) {\n    return multicast(function () {\n      return subject;\n    }, selector)(source);\n  };\n}","map":{"version":3,"mappings":"AACA;AACA,SAASA,aAAW,QAAM,kBAAc;AASxC,SAAMC,SAAU,qBAAoB;OAKlC,SAAIC,aAAmB,WAAW,iCAAkC,EAAEC;MACpEC,mBAAY,8BAAoB;IACjCD;EAED;EACA,IAAME,QAAO,GAAG,OAAID,mBAAiB,KAAY,UAAY,sBAAW;EAExE,WAAO,OAACJ,aAA0B,aAAUM,qBAAM;EACnD;IAAA;MAAA;IAAA;EAAA","names":["ReplaySubject","multicast","publishReplay","scheduler","selectorOrScheduler","selector","windowTime"],"sources":["/Users/air/Downloads/ABLC/node_modules/rxjs/src/internal/operators/publishReplay.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, O extends ObservableInput<any>>(bufferSize?: number, windowTime?: number, selector?: (shared: Observable<T>) => O, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}